/**
 * GitHub Issue Generator — creates draft issues via gh CLI
 *
 * Used by daily_briefing to convert deferred items and production alerts
 * into actionable GitHub issues for the watcher to pick up.
 */

import { execFileSync } from 'child_process';
import { logger } from '../../../config/logger.js';

const GH_BIN = process.env.GH_BIN || 'gh';
const DEFAULT_REPO = process.env.WATCHER_REPO || 'Sn1ckerDood1e/Radl';
const MAX_ISSUES_PER_BRIEFING = 3;

export interface IssueInput {
  title: string;
  description: string;
  criteria: string[];
  effort: string;
  source: string;
}

export interface CreatedIssue {
  number: number;
  title: string;
  url: string;
}

function ghAvailable(): boolean {
  try {
    execFileSync(GH_BIN, ['auth', 'status'], { timeout: 5000, stdio: 'pipe' });
    return true;
  } catch {
    return false;
  }
}

export function formatIssueBody(input: IssueInput): string {
  const date = new Date().toISOString().split('T')[0];
  const criteriaList = input.criteria.length > 0
    ? input.criteria.map(c => `- [ ] ${c}`).join('\n')
    : '- [ ] Implementation works as described';

  return `## Description

${input.description}

## Acceptance Criteria

${criteriaList}

## Details

- **Source:** ${input.source}
- **Estimated effort:** ${input.effort}
- **Auto-generated by:** radl-ops daily briefing on ${date}

---
*Add the \`approved\` label to have the watcher implement this automatically.*`;
}

export function findDuplicateIssues(title: string, repo: string = DEFAULT_REPO): boolean {
  try {
    // Search open issues with first 5 significant words from title
    const words = title.split(/\s+/).filter(w => w.length > 2).slice(0, 5);
    if (words.length === 0) return false;

    const query = words.join(' ');
    const result = execFileSync(GH_BIN, [
      'issue', 'list',
      '--repo', repo,
      '--state', 'open',
      '--search', query,
      '--json', 'number,title',
      '--limit', '5',
    ], { timeout: 10000, stdio: 'pipe' });

    const issues = JSON.parse(result.toString()) as Array<{ number: number; title: string }>;

    // Fuzzy match: check if any existing issue title shares 60%+ words with the new title
    const titleWords = new Set(title.toLowerCase().split(/\s+/).filter(w => w.length > 2));
    for (const issue of issues) {
      const existingWords = new Set(issue.title.toLowerCase().split(/\s+/).filter(w => w.length > 2));
      let matches = 0;
      for (const word of titleWords) {
        if (existingWords.has(word)) matches++;
      }
      const similarity = titleWords.size > 0 ? matches / titleWords.size : 0;
      if (similarity >= 0.6) {
        logger.info('Duplicate issue detected, skipping', {
          newTitle: title,
          existingTitle: issue.title,
          existingNumber: issue.number,
          similarity,
        });
        return true;
      }
    }

    return false;
  } catch {
    // If search fails, allow creation (better to create a near-duplicate than miss it)
    return false;
  }
}

export function createDraftIssue(
  input: IssueInput,
  labels: string[] = ['draft', 'watcher'],
  repo: string = DEFAULT_REPO,
): CreatedIssue | null {
  const body = formatIssueBody(input);

  // Use execFileSync with argument array to prevent shell injection
  // (issue titles from AI-generated content could contain backticks, $(), etc.)
  const args = [
    'issue', 'create',
    '--repo', repo,
    '--title', input.title,
    '--body', body,
    ...labels.flatMap(l => ['--label', l]),
    '--json', 'number,title,url',
  ];

  try {
    const result = execFileSync(GH_BIN, args, { timeout: 15000, stdio: 'pipe' });

    const parsed = JSON.parse(result.toString()) as CreatedIssue;
    logger.info('Draft issue created', {
      number: parsed.number,
      title: parsed.title,
      source: input.source,
    });
    return parsed;
  } catch (error) {
    const msg = error instanceof Error ? error.message : 'Unknown error';
    logger.error('Failed to create draft issue', { title: input.title, error: msg });
    return null;
  }
}

export function createIssuesFromBriefing(
  items: IssueInput[],
  repo: string = DEFAULT_REPO,
): { created: CreatedIssue[]; skipped: string[]; errors: string[] } {
  const created: CreatedIssue[] = [];
  const skipped: string[] = [];
  const errors: string[] = [];

  if (!ghAvailable()) {
    errors.push('gh CLI not available or not authenticated — skipping issue creation');
    return { created, skipped, errors };
  }

  // Limit to prevent flooding
  const toProcess = items.slice(0, MAX_ISSUES_PER_BRIEFING);

  for (const item of toProcess) {
    if (findDuplicateIssues(item.title, repo)) {
      skipped.push(item.title);
      continue;
    }

    const issue = createDraftIssue(item, ['draft', 'watcher'], repo);
    if (issue) {
      created.push(issue);
    } else {
      errors.push(`Failed to create: ${item.title}`);
    }
  }

  if (items.length > MAX_ISSUES_PER_BRIEFING) {
    skipped.push(`${items.length - MAX_ISSUES_PER_BRIEFING} additional items deferred (max ${MAX_ISSUES_PER_BRIEFING}/briefing)`);
  }

  return { created, skipped, errors };
}
